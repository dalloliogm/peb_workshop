---
title: "PEB advanced R workshop"
author: "GIovanni M DallOlio"
date: "19/04/2015"
output: html_document
---

Welcome to the PEB advanced R workshop! 



Requirements
-------------


Let's install all the required packages:

```{r}
pkgs = c("tidyr", "dplyr", "ggplot2", "reshape2")
#for (pkg in pkgs) install.packages(pkg)
for (pkg in pkgs) library(pkg, character.only=T)
```

The tidyr package requires at least R 3.1.2. If you can't install it, you can use reshape2 instead, but you won't be able to follow some of the exercises.

We also need to download the **data file**:

```{r}
#download.file('https://raw.githubusercontent.com/dalloliogm/peb_workshop/master/peb_expression.csv', dest='peb_expression.csv')
```


the peb_expression.csv file
-----------------------------

Let's read the exercise file, and have a look at its contents.

```{r}
peb = read.table("peb_expression.csv", header=T, sep='\t')
head(peb)
summary(peb)

```

The first two columns contain the probe ID and the name of the gene. The other columns contain the expression levels of each gene in an individual. Notice how the name of the columns also encode the population of each individual, e.g. YRI, EUR, or EAS.


A piping system for R
----------------------

The dplyr package introduced a piping system for R, using the %>% symbol.

This works similarly to the | in bash. We first write the name of the dataframe to use, then all the operation that must be executed on it.

For example, the following is equivalent to head(peb)

```{r}
peb %>% head
```



Converting to a long format
------------------------------

All the functions used in the rest of the workshop require the dataset to be in a long format. Let's convert it using the gather() function from tidyr:


```{r}
peb.long = gather(peb, sample, expression, -ID_REF, -IDENTIFIER)
head(peb.long)
```

Explanation:

- sample is the name of the new column containing the key variables
- expression is the new column containing the values variable
- we use the - operator to define which columns must not be converted to the long format

Note how the new format has only four columns.

If you couldn't install the tidyr package, you can achieve the same format using the *melt* function from reshape2

```{r}
peb.long = melt(peb, id.vars=c("ID_REF", "IDENTIFIER"), variable.name="sample")
names(peb.long)[4] = "expression"
head(peb.long, 3)
```



Tidying-up the peb.long dataframe
---------------------------------------------

In a properly structured table each variable must contain only one type of information. If we look at our peb.long dataframe, the sample column contains both the individual ID and its population. Let's split this column into two using *separate* from tidyr:


```{r}
peb.long.tmp = gather(peb, sample, expression, -ID_REF, -IDENTIFIER)
peb.long     = separate(peb.long.tmp, sample, into=c("individual", "population"), sep='\\.')
```

The above code can be simplified using the %>% operator:
```{r}
peb.long = peb %>% 
  gather(sample, expression, -ID_REF, -IDENTIFIER) %>%
  separate(sample, into=c("individual", "population"), sep='\\.')
```


To prepare the dataset for our workshop, we need to apply a few more data filtering steps, like removing all the "Control" rows, eliminating all the duplicated genes (keeping only one probe per gene), and dropping the ID_REF column. 


```{r}
peb.long %>% nrow

peb.long = peb %>% 
  gather(sample, expression, -ID_REF, -IDENTIFIER) %>%
  separate(sample, into=c("individual", "population"), sep='\\.') %>%
  subset(!grepl("Control", IDENTIFIER)) %>%
  subset(!duplicated(IDENTIFIER)) %>%
  select(-ID_REF)

peb.long %>% nrow
```



Group operations
----------------------

Apart from the %>% operator, the dplyr library introduces three useful functions: group_by, summarise and mutate.

- *group_by* is used to define how the rows of a dataset must be grouped. For example, we can group the rows of peb.long by population.

- *summarise* is used to calculate summaries of a grouped dataset - for example we can use it to calculate the mean and standard deviation of the expression for every population:

```{r}
peb.means = peb.long %>% 
  group_by(population) %>%
  summarise(
    mean=mean(expression),
    sd=sd(expression))

peb.means %>% print

```

- *mutate* is used to add columns to a data frame. For example we can use it to check if a given gene is expressed more or less than the mean in a given individual:


```{r}
peb.overexpressed = peb.long %>% 
  group_by(population) %>%
  mutate(
    mean.expression=mean(expression)
    ) %>%
  mutate(
    overexpressed = ifelse(expression > mean.expression, "overexpressed", "underexpressed")
  )

peb.overexpressed %>% print

```


Plotting the dataset
------------------------

We will use the ggplot2 package to plot our peb.long dataframe.

A ggplot2 plot is composed by a base ggplot() object, defining the dataset and the basic variables used, and by additional elements defining how to represent them. Let's see an example:


```{r}

ggplot(peb.long, aes(x=population, y=expression)) +
  geom_point() + 
  ggtitle("My first ggplot")

```

Explanation:

- *ggplot(peb.long, aes(x=population, y=expression))* initialize the base ggplot2 object. We use the aes (for aesthetic) function to define the default x and y variables

- *geom_point* adds a scatterplot representation of the base plot

- *ggtitle* is another element of the plot, in this case the title.

Let' try a boxplot representation:

```{r}

ggplot(peb.long, aes(x=population, y=expression)) +
  geom_boxplot()

```



Classifying cancer genes
------------------------


Let's download a file containing the classification of genes into oncogenes and tumor suppressors:

```{r}
#download.file('https://raw.githubusercontent.com/dalloliogm/peb_workshop/master/cancer_genes.csv', dest='cancer_genes.csv')
cancer = read.table("cancer_genes.csv", header=T)
cancer %>% head

```

This file doesn't follow the principles of "tidy" data, according to which each row should represent only one single observation.

In this case we can use the unnest function from tidyr to convert it to a "long" format:


```{r}
cancer.long = cancer %>%
    mutate(genes=strsplit(as.character(genes), ",") ) %>%
    unnest(genes) %>%
    rename(IDENTIFIER=genes)


cancer.long %>% head
```

Now we can use left_join from dplyr to add a column to our peb expression data frame:


```{r}
peb.long = peb.long %>%
    left_join(cancer.long, by='IDENTIFIER') %>%
    mutate(IDENTIFIER = ifelse(is.na(IDENTIFIER), "no-cancer", IDENTIFIER))

```


advanced ggplot2
---------------------


Now that we have two qualitative variables in peb.long, we can create more sophisticated plots.

```{r}

ggplot(peb.long, aes(x=population, y=expression, color=dataset)) +
    geom_boxplot()

```


An useful way to represent multi-dimensional data is facetting:

```{r}

ggplot(peb.long, aes(x=population, y=expression, color=dataset)) +
    facet_wrap(~dataset) +
    geom_boxplot()

```


